inline int toIntstring s 3
int toIntstring s int 3
toIntstring s int v 3
s int v istringstream 3
int v istringstream sinssinvreturn 3
templateclass T inline string 3
T inline string toStringT 3
inline string toStringT x 3
string toStringT x ostringstream 3
toStringT x ostringstream soutsoutxreturn 3
typedef unsigned long long 12
define EACHic fortypeofcbegin icbegin 3
EACHic fortypeofcbegin icbegin icend 3
define MTabc MPa MPb 3
define REPin for int 6
REPin for int i0 3
for int i0 iintn 3
int i0 iintn i 3
define REP1iab for int 3
REP1iab for int iinta 3
for int iinta iintb 3
int iinta iintb i 3
define FORitc for auto 3
FORitc for auto itcbegin 3
for auto itcbegin itcend 3
auto itcbegin itcend it 3
void RI int head 3
RI int head T 3
int head T tail 3
void dump const char 6
dump const char s 6
const char s T 6
char s T head 6
s T head cerrsheadendl 3
s T head Args 3
T head Args tail 3
cout < PRETTYFUNCTION < 3
while s | c0 3
if s | s 6
s | s | 6
| s | s 6
ostream out ostream s 3
out ostream s Iter 3
ostream s Iter b 3
s Iter b Iter 3
Iter b Iter e 3
for auto itb ite 3
auto itb ite it 3
itb ite it sitb 3
ostream operator < ostream 12
operator < ostream s 12
< ostream s const 12
ostream s const pairAB 3
s const pairAB p 3
const pairAB p return 3
pairAB p return spfirstpsecond 3
ostream s const vectorT 3
s const vectorT c 3
const vectorT c return 3
vectorT c return outsALLc 3
ostream s const setT 3
s const setT c 3
const setT c return 3
setT c return outsALLc 3
ostream s const mapAB 3
s const mapAB c 3
const mapAB c return 3
mapAB c return outsALLc 3
int mul int x 1
mul int x int 1
int x int y 1
for int in i1 1
int in i1 i 1
int main int argc 3
main int argc char 3
int argc char argv 3
int cielint a int 1
cielint a int b 1
int solveint D d 1
solveint D d = 1
D d = of 1
d = of diners 1
= of diners Plate 1
of diners Plate sizes 1
diners Plate sizes stored 1
Plate sizes stored in 1
Plan all special minutes 1
all special minutes come 1
Will take as many 1
take as many special 1
as many special minutes 1
many special minutes as 1
special minutes as possible 1
minutes as possible to 1
as possible to split 1
possible to split all 1
to split all piles 1
split all piles into 1
all piles into at 1
piles into at most 1
Find the best possible 1
for int k1 k1000 1
int k1 k1000 k 1
for int i0 iD 4
int i0 iD i 3
int T cin > 6
for int t1 tT 6
int t1 tT t 6
int D cin > 1
for int d0 dD 1
int d0 dD d 1
d0 dD d cin 1
dD d cin > 1
define dfodiab for d 3
dfodiab for d i 3
for d i = 12
d i = a 6
i = a i 30
= a i < 27
a i < b 18
define dfediab for d 3
dfediab for d i 3
define dffodiab for d 3
dffodiab for d i 3
d i = b1 3
i = b1 i 3
= b1 i > 3
b1 i > a 3
define dffediab for d 3
dffediab for d i 3
d i = b 3
i = b i 3
= b i > 3
b i > a 3
frin sfd p + 1
sfd p + i 1
p + i m 1
+ i m = 1
i m = m 1
m = m > 1
= m > pi 1
m > pi m 1
int cur = ptl 1
cur = ptl + 1
if ans > cur 1
ans > cur ans 1
> cur ans = 1
pfCase d dn cas 2
define repin for int 3
repin for int i 3
for int i = 138
int i = 0 83
i = 0 i 120
= 0 i < 120
0 i < n 34
define repnian for int 3
repnian for int i 3
int i = a 18
a i < n 6
const int N = 2
for int Ti = 2
int Ti = 1 2
Ti = 1 Ti 3
= 1 Ti < 3
1 Ti < T 3
int tot = 0 1
tot = 0 ans 1
= 0 ans = 5
i < n + 5
< n + si 1
n + si - 1
< n + if 2
n + if si 1
+ if si = 1
if tot < i 1
tot < i ans 1
< i ans + 2
i ans + i 2
ans + i - 8
+ i - tot 1
i - tot tot 1
- tot tot = 1
printfCase d dn Ti 2
define FOiab for int 6
FOiab for int i 6
int quarMult int a 1
quarMult int a int 1
int a int b 5
int sgn = ab 1
sgn = ab < 1
long long totLength = 1
long long m4 = 1
long m4 = X 1
fRep = quarMult fRep 1
if fRep = TARGET 1
long long fStar = 1
for long long i 8
long long i = 8
long i = 0 3
0 i < mintotLength5L 1
i < mintotLength5L i 1
if startRep = 2 1
long long sStar = 1
long i = totLength1 1
i = totLength1 i 1
= totLength1 i > 1
totLength1 i > max 1
i > max 05 1
> max 05 i 1
startRep = quarMult inpiL 1
if startRep = 4 1
if fStar = -1 1
fStar = -1 | 1
= -1 | sStar 1
-1 | sStar = 1
| sStar = -1 1
if fStar < sStar 1
int multint a int 4
multint a int b 4
if a > 4 2
if b > 4 2
if a0 | b 1
a0 | b = 1
| b = 0 1
b = 0 return 1
= 0 return a 1
0 return a + 1
if a = b 2
a = b return 2
if a > b 1
a > b return 1
Now can assume 13. 1
can assume 13. Three 1
assume 13. Three cases 1
if a1 b = 2
a1 b = 2 1
b = 2 return 3
a1 b = 3 1
b = 3 return 4
if a2 b = 1
a2 b = 3 1
Cache of multiplication for 1
int powint a ll 1
powint a ll e 1
if e > 4 1
e > 4 return 1
prefi is the product 1
is the product of 1
the product of the 1
product of the first 1
of the first i 1
the first i symbols 1
first i symbols not 1
i symbols not including 1
symbols not including index 1
ll LX cin > 2
LX cin > L 2
cin > L > 11
string s cin > 2
for int l0 lL 2
int l0 lL l 2
if total = 4 1
total = 4 return 1
for int m0 m4 1
int m0 m4 mX 1
m0 m4 mX m 1
if val = 1 1
val = 1 firstI 1
= 1 firstI = 1
if val = 3 1
ll m1 = llm4 1
m1 = llm4 Xm14 1
if firstI < lastK 1
firstI < lastK return 1
for int a0 a8 1
int a0 a8 a 1
a0 a8 a for 1
a8 a for int 1
a for int b0 1
for int b0 b8 1
int b0 b8 b 1
b0 b8 b mcab 1
b8 b mcab = 1
int V44 = 1 1
V44 = 1 2 1
= 1 2 3 1
1 2 3 4 1
2 3 4 2 1
3 4 2 -1 1
4 2 -1 4 1
2 -1 4 -3 1
-1 4 -3 3 1
4 -3 3 -4 1
-3 3 -4 -1 1
3 -4 -1 2 1
-4 -1 2 4 1
-1 2 4 3 1
2 4 3 -2 1
4 3 -2 -1 1
int valueint X char 1
int Y = c 1
Y = c = 1
return X > 0 1
X > 0 VX 1
> 0 VX - 1
0 VX - 1 1
VX - 1 - 1
- 1 - - 1
bool solveconst string W 1
solveconst string W int 1
int a = 2 1
a = 2 q 1
= 2 q = 1
return a = 5 1
a = 5 q 1
= 5 q = 1
> L > X 4
L > X > 4
X = X 4 2
= X 4 + 2
printfCase d sn t 1
d sn t + 1
sn t + 1 1
t + 1 solveword 1
+ 1 solveword L 1
int S A = 1
S A = 0 1
A = 0 B 1
= 0 B = 1
cin > S > 1
ifA + B < 1
A + Vi - 1
printfCase d dn t 8
d dn t + 2
dn t + 1 2
int cas n l 1
cas n l r 1
n l r mid 1
i < n i 17
for int T = 3
int T = 1 3
T = 1 T 3
= 1 T < 3
1 T < cas 3
T < cas T 3
< n i + 7
n i + ai 2
i + ai = 2
+ ai = chi 1
ai = chi - 1
l = 0 r 2
= 0 r = 2
0 r = n 1
mid = l + 1
= l + r 3
l + r > 1
ans = mid r 1
= mid r = 1
mid r = mid 1
r = mid - 1
l = mid + 1
= mid + 1 1
printfCase d dn T 2
int cas n limit 1
cas n limit ans 1
n limit ans int 1
int i = 1 25
i = 1 i 37
= 1 i < 37
1 i < 1000 4
i < 1000 i 3
for int j = 25
int j = 1 6
j = 1 j 7
= 1 j < 7
1 j < 1000 1
j < 1000 j 1
for int k = 7
int k = 1 2
k = 1 k 2
= 1 k < 2
1 k < j 2
k < j k 1
fij = minfik + 1
= minfik + fij 1
minfik + fij - 1
+ fij - k 1
fij - k + 1
- k + 1 1
scanfd n limit = 1
1 i < n 8
1 j < limit 1
j < limit j 1
inline Q operatorconst Q 1
cout < flag < 1
else if c = 3
else if rhsc = 6
const long long N 1
long long N = 1
long long T n 1
for long long Ti 1
long long Ti = 1
long Ti = 1 1
cin > n > 7
0 i < ssize 1
ai + 1. = 2
long i = 1 4
< n + mul 1
n + mul = 1
+ mul = mul 1
long long nx = 1
long nx = x 1
nx = x 4 1
= x 4 + 1
1 i < nx 1
i < nx + 1
< nx + tmp 1
nx + tmp = 1
+ tmp = tmp 1
if x > 100 1
x > 100 x 1
> 100 x = 1
long long min = 1
long min = 1000000000000000 1
min = 1000000000000000 max 1
= 1000000000000000 max = 1
1 i < x 1
for long long j 1
long long j = 1
long j = 1 1
1 j < n 4
cout < tmpc < 1
if i - 1 2
i - 1 n 4
- 1 n + 8
1 n + j 2
n + j < 1
+ j < min 1
j < min min 1
< min min = 2
min min = i 1
min = i - 1
= i - 1 2
n + j > 1
+ j > max 1
j > max max 1
> max max = 1
max max = i 1
max = i - 1
if min < 1000000000000000 1
min < 1000000000000000 max 1
< 1000000000000000 max > 1
1000000000000000 max > 0 1
max > 0 min 1
> 0 min < 1
define REPin forint i 3
REPin forint i = 3
forint i = 0 29
i = 0 in 3
define ITERiv forauto i 3
const bool DEBUG = 6
using priorityqueueasc = priorityqueueTvectorT 3
priorityqueueasc = priorityqueueTvectorT greaterT 3
int mintimemaxelementFp just dont 1
forint target = 1 1
target = 1 target 1
= 1 target < 1
1 target < mintime 1
for int cn = 3
int cn = 1 3
cn = 1 cn 3
= 1 cn < 3
1 cn < T 3
cn < T + 3
int D ans = 1
0 i < D 8
i < D + 3
< D + scanfd 1
for int mx = 1
int mx = 1 1
mx = 1 mx 1
= 1 mx < 1
1 mx < 1000 1
mx < 1000 + 1
req + Ai + 1
+ Ai + mx 1
Ai + mx - 1
+ mx - 1 1
mx - 1 mx 1
- 1 mx - 1
printfCase d dn cn 2
int mint a int 1
int a2 = a 1
ifa2 = 0 | 1
= 0 | b2 1
0 | b2 = 1
| b2 = 0 1
b2 = 0 return 1
ifa2 = b2 return 1
ifa2 = 1 b2 2
= 1 b2 = 2
1 b2 = 2 1
b2 = 2 return 2
ifa2 = 2 b2 2
= 2 b2 = 2
2 b2 = 3 1
b2 = 3 return 2
ifa2 = 3 b2 2
= 3 b2 = 2
3 b2 = 1 1
b2 = 1 return 2
2 b2 = 1 1
3 b2 = 2 1
1 b2 = 3 1
FILE fin = freopenClargein 1
FILE fout = freopenClargeout 1
forint t = 1 12
t = 1 t 22
= 1 t < 22
1 t < T 12
cin > l > 5
0 i < 8 2
forint j = 0 7
j = 0 j 25
= 0 j < 25
0 j < 8 3
cout < mij < 1
forLL i = 0 4
0 i < l 3
int num = ki 1
num = ki - 1
cout < prodseg < 1
0 i < x4 1
0 i < 5 1
int num = kil 2
num = kil - 2
forLL i = 51 1
i = 51 i 1
= 51 i 0 1
ifminleft = -1 | 1
= -1 | minright 1
-1 | minright = 1
ifminleft + minright < 1
define ull unsigned long 6
qchar c symc postrue 1
bool operatorconst q other 2
operatorconst q other return 2
q other return sym 1
other return sym = 1
return sym = othersym 1
sym = othersym pos 1
= othersym pos = 1
othersym pos = otherpos 1
q other return this 1
other return this = 1
return this = other 1
q mulq a q 1
mulq a q b 1
if asym = bsym 1
asym = bsym ressym 1
= bsym ressym = 1
q qmulbyq b this 1
qmulbyq b this = 1
b this = multhis 1
this = multhis b 1
= multhis b return 1
multhis b return this 1
char mulchar a char 1
mulchar a char b 1
int X4 = X 1
if all = mulqi 1
all = mulqi mulqj 1
= mulqi mulqj qk 1
printfCase d NOn t 1
REPi L 5 + 2
L 5 + 2 2
printfc d with c 1
d with c d 1
if start = qi 1
firstI = i + 1
end = mulxL 9 1
= mulxL 9 - 1
mulxL 9 - i 1
9 - i - 1
- i - 1 1
i - 1 L 1
if end = qk 1
lastK = i + 1
if firstI = -1 1
firstI = -1 | 1
= -1 | lastK 1
-1 | lastK = 1
| lastK = -1 1
lastK = -1 | 1
= -1 | firstI 1
-1 | firstI + 1
| firstI + lastK 1
firstI + lastK > 1
+ lastK > L 1
lastK > L X 1
define FORprom a b 3
FORprom a b forint 3
a b forint prom 9
b forint prom = 9
forint prom = a 9
prom = a prom 9
= a prom < 3
a prom < b 3
define FORDprom a b 3
FORDprom a b forint 3
= a prom > 6
a prom > b 6
define FORDEprom a b 3
FORDEprom a b forint 3
define DRIa int a 3
DRIa int a scanfd 3
define DRIIa b int 3
DRIIa b int a 3
b int a b 3
int a b scanfd 3
a b scanfd d 3
define DRIIIa b c 3
DRIIIa b c int 3
b c int a 3
c int a b 3
int a b c 6
a b c scanfd 3
b c scanfd d 6
c scanfd d d 6
define DRIIIIa b c 3
DRIIIIa b c d 3
b c d int 3
c d int a 3
d int a b 3
a b c d 3
b c d scanfd 6
c d scanfd d 6
d scanfd d d 6
scanfd d d d 6
define RIIa b scanfd 3
RIIa b scanfd d 3
define RIIIa b c 3
RIIIa b c scanfd 3
define RIIIIa b c 3
RIIIIa b c d 3
define MMco cim memsetco 3
MMco cim memsetco cim 3
define DEBx cerr < 3
ifPd p = 0 1
printfCase d dn t1 2
define fornabc for int 3
dpij = dpij1 + 1
fornk1j1 dpij = mindpijdpijk 1
dpij = mindpijdpijk + 1
= mindpijdpijk + dpik 1
mindpijdpijk + dpik + 1
ans = minanstot + 1
if i < 20 1
i < 20 printfd 1
define FOREACHitvec fortypeofvecbegin it 3
FOREACHitvec fortypeofvecbegin it = 3
fortypeofvecbegin it = vecbegin 3
it = vecbegin it 3
= vecbegin it = 3
vecbegin it = vecend 3
define REPian for int 3
REPian for int i 3
for int test = 3
int test = 0 3
test = 0 test 3
= 0 test < 3
0 test < T 3
test < T test 3
FILE reader = fopenBlargein 1
for int opt1 opt1000 1
int opt1 opt1000 opt 1
const int maxl = 1
enum quat quatrmulenum quat 1
quat quatrmulenum quat q 1
quatrmulenum quat q enum 1
quat q enum quat 2
if q > 4 2
q = enum quat 4
= enum quat q 4
enum quat q - 2
if r > 4 1
r = enum quat 1
= enum quat r 1
enum quat r - 1
breakcase QUAT1 switch r 1
breakcase QUAT1 q = 8
breakcase QUATI q = 8
breakcase QUATJ q = 8
breakcase QUATK q = 8
breakcase QUATI switch r 1
breakcase QUATJ switch r 1
breakcase QUATK switch r 1
enum quat q + 2
quat q + 4 2
enum quat quatlmulenum quat 1
quat quatlmulenum quat q 1
quatlmulenum quat q enum 1
if l > 4 1
l = enum quat 1
= enum quat l 1
enum quat l - 1
breakcase QUAT1 switch q 1
breakcase QUATI switch q 1
breakcase QUATJ switch q 1
breakcase QUATK switch q 1
int y = int 1
y = int x 1
enum quat total = 1
0 i < y 1
i < y i 1
int j = 0 17
0 j < l 3
j < l j 3
enum quat left = 1
0 i < 4 10
i < 4 i 5
enum quat right = 1
quatlmulright quatletterstrl - j 1
return leftpos + rightpos 1
leftpos + rightpos < 1
+ rightpos < l 1
0 i < t 3
i < t i 3
const int S44 = 1
const int Y44 = 1
Qint s int n 1
s int n signs 1
int n signs nn 1
assertsign = -1 | 1
= -1 | sign 1
-1 | sign = 1
assert0 < n n 1
< n n < 1
bool operator = const 2
operator = const Q 2
= const Q q 2
return sign = qsign 2
sign = qsign | 1
= qsign | n 1
qsign | n = 1
sign = qsign n 1
= qsign n = 1
Q multiplyconst Q p 1
multiplyconst Q p const 1
Q p const Q 1
p const Q q 1
Q respsign qsign Spnqn 1
Q powQ p long 1
powQ p long long 1
p long long k 1
if k 1 res 1
k 1 res = 1
1 res = multiplyres 1
Q I1 1 K1 1
1 j < X 1
0 i < L 9
sj L + i 1
L + i = 1
int pl = -1 1
pl = -1 sl 1
= -1 sl = 1
pre0 = Q1 s0 1
= Q1 s0 - 1
sufL - 1 = 1
- 1 = Q1 2
1 = Q1 sL 1
= Q1 sL - 1
Q1 sL - 1 1
sL - 1 - 1
1 i < L 5
prei = multiplyprei - 1
= multiplyprei - 1 1
multiplyprei - 1 Q1 1
- 1 Q1 si 1
1 Q1 si - 1
int i = L 2
i = L - 2
= L - 2 1
L - 2 i 1
- 2 i > 1
2 i > 0 1
sufi = multiplyQ1 si 1
= multiplyQ1 si - 1
if prei = I 1
pl = i + 1
= L - 1 2
L - 1 i 1
- 1 i > 1
1 i > 0 1
if sufi = K 1
sl = L - 1
if pl = -1 1
pl = -1 | 1
= -1 | sl 1
-1 | sl = 1
| sl = -1 1
sl = -1 | 1
= -1 | preL 1
-1 | preL - 1
| preL - 1 1
preL - 1 = 1
1 = Q1 0 1
= Q1 0 | 1
Q1 0 | pl 1
0 | pl + 1
| pl + sl 1
pl + sl > 1
+ sl > L 1
if powpreL - 1 1
powpreL - 1 X 1
- 1 X = 1
1 X = Q1 1
X = Q1 0 1
Q w4 = Q1 1
1 i < 4 3
i < 4 + 5
< 4 + wi 1
4 + wi = 1
+ wi = multiplywi 1
wi = multiplywi - 1
= multiplywi - 1 1
multiplywi - 1 preL 1
- 1 preL - 1
long long is = 1
long is = -1 1
is = -1 il 1
= -1 il = 1
if wi = I 1
is = i il 2
= i il = 2
0 j < L 2
if multiplywi prej = 1
multiplywi prej = I 1
i il = j 1
il = j + 1
if is = -1 2
long long ks = 1
long ks = -1 1
ks = -1 kl 1
= -1 kl = 1
if wi = K 1
ks = i kl 2
= i kl = 2
int j = L 1
j = L - 1
L - 1 j 1
- 1 j > 1
1 j > 0 1
if multiplysufj wi = 1
multiplysufj wi = K 1
i kl = L 1
kl = L - 1
if ks = -1 1
is = -1 | 1
= -1 | ks 1
-1 | ks = 1
| ks = -1 1
ks = -1 | 1
= -1 | is 1
-1 | is + 1
| is + ks 1
is + ks L 1
+ ks L + 1
ks L + il 1
L + il + 1
+ il + kl 1
il + kl > 1
+ kl > X 1
kl > X L 1
printfnlld lldn is L 1
lldn is L + 1
is L + il 1
L + il ks 1
+ il ks L 1
il ks L + 1
for int = 1 3
int = 1 < 3
= 1 < T 3
1 < T + 3
B - Infinite House 1
- Infinite House of 1
for int h = 4
int h = 1 3
h = 1 h 4
= 1 h < 4
1 h < t 3
h < t h 3
mx = mx > 1
= mx > dineri 1
mx > dineri mx 1
1 i < mx 1
i < mx i 1
0 j < n 4
j < n j 4
< n j cnt 1
n j cnt + 1
j cnt + dinerj 1
cnt + dinerj - 1
+ dinerj - 1 1
mn = mn < 1
= mn < cnt 1
mn < cnt mn 1
const int maxk = 1
const int maxn = 4
int maxn = int 1
maxn = int 14 1
= int 14 + 1
k = mink 20 1
= mink 20 + 1
mink 20 + k 1
ai = findcode code 1
= findcode code + 1
findcode code + 4 1
code + 4 stri 1
+ 4 stri - 1
i < n k 1
0 j < 3 1
for int cur = 2
int cur = 0 2
cur = 0 cur 1
= 0 cur < 1
0 cur < 4 1
for int s = 2
int s = 0 3
s = 0 s 2
= 0 s < 2
0 s < 2 1
if s = 0 1
s = 0 cur 1
= 0 cur = 2
0 cur = j 1
cur = j + 1
dpij + 100 = 1
int ns = s 1
ns = s sgncurai 1
int nxt = mulcurai 1
dpi + 1 = 1
1 i < t 3
int fakeproduitint a int 1
ifa = 1 return 1
else ifb = 1 1
ifb = 1 return 1
else ifa = b 1
ifa = b return 1
else ifa = 2 2
ifa = 2 b 2
= 2 b = 2
2 b = 3 1
2 b = 4 1
b = 4 return 2
else ifa = 3 2
ifa = 3 b 2
= 3 b = 2
3 b = 2 1
3 b = 4 1
else ifa = 4 2
ifa = 4 b 2
= 4 b = 2
4 b = 2 1
4 b = 3 1
int produitint a int 1
int res = fakeproduita 1
long long int L 1
si = c - 1
forint i = 1 8
valuegi = produitvaluegi1 si1 1
= produitvaluegi1 si1 Produit 1
produitvaluegi1 si1 Produit des 1
si1 Produit des i 1
Produit des i premiers 2
des i premiers termes 2
i premiers termes en 2
premiers termes en partant 2
termes en partant de 2
en partant de la 2
valuedi = produitsLi valuedi1 1
= produitsLi valuedi1 Produit 1
produitsLi valuedi1 Produit des 1
valuedi1 Produit des i 1
long long int x 1
long int x = 1
long long int trouvex 1
whilex = 0 | 2
= 0 | blocentier 2
0 | blocentier = 2
| blocentier = 1 2
blocentier = 1 trouve 1
= 1 trouve x 1
1 trouve x < 1
i < L trouve 1
long long int trouvex2 1
blocentier = 1 trouve2 1
= 1 trouve2 x 1
1 trouve2 x < 1
i < L trouve2 1
long long int total 1
long int total = 1
int total = L 1
total = L trouvex 1
= L trouvex + 1
L trouvex + trouvei 1
trouvex + trouvei + 1
+ trouvei + L 1
trouvei + L trouvex2 1
+ L trouvex2 + 1
iftotal > long long 1
It remains to have 1
remains to have ijk 1
to have ijk in 1
have ijk in total 1
ijk in total ie 1
ifX 2 = 1 1
2 = 1 ok 2
= 1 ok = 2
ifX 4 = 2 1
4 = 2 ok 2
= 2 ok = 2
char updatechar c char 1
updatechar c char nx 1
c char nx int 1
char nx int sgn 1
else ifnextc = nx 1
else ifc = nextnx 1
t < T t 3
c = updatec si 2
= updatec si sgn 1
forint = 0 < 2
= 0 < 10 2
< n i cnt 1
forint i = n1 1
i = n1 i 1
= n1 i > 1
n1 i > 0 1
i > 0 i 1
> 0 i cnt2 1
c = updatesi c 1
ifcnt + cnt2 < 1
define vpii vector pairintint 3
define FOREACHitx for auto 3
FOREACHitx for auto it 3
for auto it = 3
auto it = xbegin 3
it = xbegin itxend 3
= xbegin itxend + 3
define FORin for ll 3
FORin for ll i 3
for ll i = 7
ll i = 0 4
0 i < lln 3
define REPiab for ll 3
REPiab for ll i 3
ll i = a 3
a i < llb 3
define READa int a 3
READa int a scanfd 3
define READVvn vi vnFORinscanfd 3
define gminab if b 3
gminab if b < 3
if b < a 3
b < a a 3
< a a = 3
a a = b 6
define gmaxab if b 3
gmaxab if b > 3
if b > a 3
b > a a 3
> a a = 3
added + need - 1
int multiplyint a int 2
multiplyint a int b 1
a > 4 neg 1
> 4 neg = 2
4 neg = 1 2
neg = 1 a 1
= 1 a - 1
b > 4 neg 1
neg = 1 b 1
= 1 b - 1
void matmulint dest2424 int 1
matmulint dest2424 int mul2424 1
0 i < 24 2
i < 24 i 2
0 j < 24 1
j < 24 j 1
int k = 0 1
k = 0 k 1
= 0 k < 1
0 k < 24 1
k < 24 k 1
int cur = 1 1
cur = 1 cur 1
= 1 cur < 1
1 cur < 3 1
cur < 3 cur 1
for int row = 1
int row = 0 1
row = 0 row 1
= 0 row < 1
0 row < 24 1
row < 24 row 1
int index = row 1
int pre = row 1
int next = multiplypre 1
transcurrow8index + next = 1
if index = 0 1
index = 0 next 1
= 0 next = 1
0 next = 1 1
index = 1 next 1
= 1 next = 1
1 next = 2 1
for int testcase = 3
int testcase = 1 3
testcase = 1 testcase 3
= 1 testcase < 3
1 testcase < T 3
testcase < T testcase 3
i < L i 3
int cur = dati 1
cur = dati - 1
printfCase d sn testcase 1
d sn testcase ans 1
< n + scanfd 1
sortp p + n 1
for int m = 1
int m = p0 1
m = p0 m 1
= p0 m > 1
p0 m > 1 1
m > 1 - 1
cnt + pi - 1
+ pi - 1 3
ans = minans cnt 1
= minans cnt + 1
define GetTime fprintfstderrRunning time 3
GetTime fprintfstderrRunning time 3 3
REPin for int i 3
define REPDin for int 3
REPDin for int i 3
int i = n1 3
i = n1 0 3
= n1 0 < 3
n1 0 < i 3
define FORiab for int 3
FORiab for int i 3
define FORDiab for int 3
FORDiab for int i 3
i = a b 3
= a b < 3
a b < i 3
define FORITitc for typeof 3
FORITitc for typeof cbegin 3
for typeof cbegin it 3
typeof cbegin it = 3
cbegin it = cbegin 3
it = cbegin it 3
= cbegin it = 3
cbegin it = cend 3
define EXISTas sfinda = 3
define MXab a = 3
define MNab a = 3
inline void OPENconst string 3
void OPENconst string s 3
- end of azakys 3
end of azakys template 3
of azakys template - 3
const int qvalue44 = 1
const int qsign44 = 1
Quaternionint sign = 1 1
sign = 1 int 1
= 1 int value 1
1 int value = 1
int value = 0 1
int sign 1 = 1
int value 0 = 1
if qsign = -1 1
Quaternion operatorconst Quaternion a 1
operatorconst Quaternion a const 1
Quaternion a const Quaternion 1
a const Quaternion b 1
int sign = qsignavaluebvalue 1
sign = qsignavaluebvalue asign 1
Quaternion resultqsignavaluebvalue asign bsign 1
printfsign d d d 1
d d d = 1
d d = dn 1
d = dn qsignavaluebvalue 1
= dn qsignavaluebvalue asign 1
dn qsignavaluebvalue asign bsign 1
printfvalue qvaluedd = dn 1
qvaluedd = dn avalue 1
= dn avalue bvalue 1
return Quaternionqsignavaluebvalue asign bsign 1
Quaternion powerQuaternion a ll 1
powerQuaternion a ll p 1
Quaternion result = powera 1
result = powera a 1
= powera a p 1
powera a p > 1
if p 1 result 1
p 1 result = 1
1 result = result 1
int mainint argc char 12
mainint argc char argv 6
if argc = 1 3
Quaternion all = powerml 1
if allsign = -1 1
allsign = -1 | 1
= -1 | allvalue 1
-1 | allvalue = 1
| allvalue = 0 1
construct the map that 1
the map that helps 1
map that helps me 1
that helps me trace 1
helps me trace your 1
find the first occurence 2
the first occurence of 2
Quaternion temp = mapd 2
if tempsign = 1 2
tempsign = 1 tempvalue 2
= 1 tempvalue = 2
1 tempvalue = 1 1
if occiA = 4 1
occiA = 4 | 1
= 4 | llocciA 1
4 | llocciA > 1
| llocciA > x 1
first occurence of ij 1
occurence of ij = 1
1 tempvalue = 3 1
pii now = MPd 1
if now < occi 1
now < occi now 1
< occi now = 1
occi now = MPd 1
now = MPd + 1
= MPd + 4 1
if occjA = 8 1
occjA = 8 | 1
= 8 | lloccjA 1
8 | lloccjA > 1
| lloccjA > x 1
const int MAXn = 1
cnt + aji1 i 1
+ aji1 i - 1
ai = stri - 1
printfCase d dn i 1
d dn i solve 1
char mult44 = 0123103223013210 1
int neg44 = 0000010101100011 1
ifX > 16 X 1
> 16 X = 1
16 X = 16 1
X = 16 + 1
= 16 + X 1
0 i < X 2
Ai L + j 1
L + j = 1
+ j = Sj 1
j = Sj - 1
i < L X 1
ifnext < 3 cur 1
< 3 cur = 1
3 cur = next 1
cout < next = 1
< next = 4 1
next = 4 cur 1
= 4 cur sgn 1
interrupt + ai - 1
+ ai - 1 3
printfCase d dn itc 2
audi = int c 1
= int c - 1
if running < i 1
cnt + i - 1
define repi n forint 3
repi n forint i0 3
n forint i0 iintn 3
if s < i 1
cout < ans < 7
forint TC1 TCT TC 2
int ans = 0 3
ans = 0 sum 1
= 0 sum = 2
int x = si 1
x = si - 1
if sum < i 3
define ulint unsigned long 3
ulint unsigned long long 3
define lint long long 3
bool operatorconst long aconst 3
operatorconst long aconst long 3
long aconst long b 3
define pophminX popheapallX minheapcomparator 3
define pushhminX Y XpbY 3
pushhminX Y XpbY pushheapallX 3
define pushhmaxX Y XpbY 3
for int t = 14
int t = 0 4
t = 0 t 4
= 0 t < 4
0 t < T 3
cin > N > 2
0 i < N 6
int h i j 1
bool eqQuat q1 Quat 1
return q1h = q2h 1
q1h = q2h q1i 1
= q2h q1i = 1
q2h q1i = q2i 1
q1i = q2i q1j 1
= q2i q1j = 1
q2i q1j = q2j 1
q1j = q2j q1k 1
= q2j q1k = 1
Quat multQuat q1 Quat 1
qh = q1hq2h - 1
= q1hq2h - q1iq2i 1
q1hq2h - q1iq2i - 1
- q1iq2i - q1jq2j 1
q1iq2i - q1jq2j - 1
qi = q1hq2i + 1
= q1hq2i + q1iq2h 1
q1hq2i + q1iq2h + 1
+ q1iq2h + q1jq2k 1
q1iq2h + q1jq2k - 1
qj = q1hq2j - 1
= q1hq2j - q1iq2k 1
q1hq2j - q1iq2k + 1
- q1iq2k + q1jq2h 1
q1iq2k + q1jq2h + 1
qk = q1hq2k + 1
= q1hq2k + q1iq2j 1
q1hq2k + q1iq2j - 1
+ q1iq2j - q1jq2i 1
q1iq2j - q1jq2i + 1
x = minx x4 1
= minx x4 + 1
1 i < N 3
i < N i 1
< N i cin 1
N i cin > 1
forint h = 1 1
1 h < 1000 1
add + Ai - 1
+ Ai - 1 1
best = minbest h 1
= minbest h + 1
define fx y z 3
fx y z forint 3
y z forint x 5
z forint x = 5
forint x = y 5
x = y x 5
= y x < 4
y x < z 4
fi 1 n scanfd 1
1 n scanfd a 1
n scanfd a + 1
fi 1 n cans 1
1 n cans + 1
n cans + ai 1
cans + ai - 1
ifcans < ans ans 1
< ans ans = 4
int seq110005 lmult110005 rmult110005 1
0 0 0 0 1
0 1 2 3 2
0 2 -1 4 1
0 3 -4 -1 1
0 4 3 -2 1
int sign = a 1
sign = a < 1
= a < 0 1
a < 0 -1 1
sign = b < 1
= b < 0 1
b < 0 -1 1
if X > 12 1
X = 8 + 1
= 8 + X 1
int N = X 1
i < N + 2
seqi + 1 = 1
+ 1 = convstri 1
int ipos = 0 1
ipos = 0 kpos 1
= 0 kpos = 1
lmulti = multlmulti - 1
= multlmulti - 1 1
if lmulti = 2 1
lmulti = 2 ipos 1
= 2 ipos ipos 1
2 ipos ipos = 1
rmultN + 1 = 1
int i = N 1
i = N i 1
= N i > 1
N i > 1 1
i > 1 - 2
rmulti = multseqi rmulti 1
= multseqi rmulti + 1
if rmulti = 4 1
rmulti = 4 kpos 1
= 4 kpos kpos 1
4 kpos kpos = 1
if lmultN = -1 1
lmultN = -1 return 1
if ipos | kpos 1
ipos | kpos | 1
| kpos | ipos 1
kpos | ipos > 1
| ipos > kpos 1
ipos > kpos return 1
FOi03 if Ci = 1
if Ci = ch 1
Ci = ch return 1
int mulint a int 1
mulint a int b 1
if a < 0 2
if b < 0 2
int pwint a ll 1
pwint a ll b 1
if b1 r = 1
int ldivint y int 1
ldivint y int i 1
FOx15 if mulxi = 2
if mulxi = y 2
mulxi = y return 2
int rdivint y int 1
rdivint y int i 1
FOx15 if mulix = 2
if mulix = y 2
mulix = y return 2
vectorint vl FOi0l vi 1
vl FOi0l vi = 1
pref0 = suff0 = 1
FOi1l1 prefi = mulprefi1 1
FOi1l1 suffi = mulvli 1
if pwprefl x = 1
pwprefl x = -1 1
spref = il + 1
ssuf = il + 1
if sprefssuf < xl 1
define INF 1 < 1
char chMAXN int aMAXN 1
int cas n ll 1
cas n ll m 1
n ll m l 1
ll m l r 1
m l r lc 1
l r lc rc 1
r lc rc bool 1
g11 = 1 g12 1
= 1 g12 = 1
1 g12 = 2 1
g12 = 2 g13 1
= 2 g13 = 1
2 g13 = 3 1
g13 = 3 g14 1
= 3 g14 = 1
g21 = 2 g22 1
= 2 g22 = 1
2 g22 = -1 1
g22 = -1 g23 1
= -1 g23 = 1
-1 g23 = 4 1
g23 = 4 g24 1
= 4 g24 = 1
g31 = 3 g32 1
= 3 g32 = 1
3 g32 = -4 1
g32 = -4 g33 1
= -4 g33 = 1
-4 g33 = -1 1
g33 = -1 g34 1
= -1 g34 = 1
g41 = 4 g42 1
= 4 g42 = 1
4 g42 = 3 1
g42 = 3 g43 1
= 3 g43 = 1
3 g43 = -2 1
g43 = -2 g44 1
= -2 g44 = 1
int multiint a int 1
int res = a 1
res = a b 1
= a b > 2
a b > 0 2
b > 0 1 2
a = absa b 1
= absa b = 1
n i + sli 1
i + sli = 1
+ sli = multisli 1
sli = multisli - 1
= multisli - 1 1
srn + 1 = 1
int i = n 1
i = n i 1
= n i i 1
n i i - 1
i i - sri 1
i - sri = 1
- sri = multiai 1
sri = multiai sri 1
= multiai sri + 1
b0 = 1 for 1
= 1 for int 1
1 for int i 1
< 4 i + 1
4 i + bi 1
i + bi = 1
+ bi = multibi 1
bi = multibi - 1
= multibi - 1 1
l = INF r 1
= INF r = 1
if multibi slj = 1
l = min1ll i 1
= min1ll i n 2
min1ll i n + 2
i n + j 2
if multisrj bi = 1
r = min1ll i 1
i n + n 1
n + n - 1
+ n - j 1
n - j + 1
- j + 1 1
if l + r 1
l + r < 1
+ r < m 1
l + r + 1
+ r + r 1
r + r = 1
+ r = m 1
r = m n 1
= m n - 1
m n - r 1
n - r + 1
lc = l - 1
= l - 1 2
l - 1 n 2
rc = r - 1
= r - 1 2
r - 1 n 2
l = l - 1
r = r - 1
int i = l 2
i = l i 2
= l i < 2
l i < r 2
i < r i 2
if res = 3 2
res = 3 flag 2
= 3 flag = 2
int res = srl 1
res = srl printfdn 1
res = multires brc 1
= multires brc - 1
multires brc - lc 1
brc - lc - 1
- lc - 1 1
lc - 1 4 1
- 1 4 printfdn 1
res = multires slr 1
= multires slr printfdn 1
for int d = 2
int d = 1 2
d = 1 d 2
= 1 d < 2
1 d < 1000 2
d < 1000 d 1
for int x v 1
int x v s 1
x v s + 1
v s + x1 1
printfCase d dn Z 2
define repii a b 3
repii a b forint 3
a b forint i 6
b forint i = 6
forint i = a 6
define repi a repii 3
repi a repii 0 3
define repdi a b 3
repdi a b forint 3
= a i > 3
a i > b 3
define repiti v fortypeofvbegin 3
repiti v fortypeofvbegin i 3
v fortypeofvbegin i = 3
fortypeofvbegin i = vbegin 3
i = vbegin i 3
= vbegin i = 3
vbegin i = vend 3
define repriti v fortypeofvrbegin 3
repriti v fortypeofvrbegin i 3
v fortypeofvrbegin i = 3
fortypeofvrbegin i = vrbegin 3
i = vrbegin i 3
= vrbegin i = 3
vrbegin i = vrend 3
repi n1 vi = 1
n1 vi = si 1
vi = si - 1
mat00 = 0 mat01 1
= 0 mat01 = 1
0 mat01 = 1 1
mat01 = 1 mat02 1
= 1 mat02 = 1
1 mat02 = 2 1
mat02 = 2 mat03 1
= 2 mat03 = 1
mat10 = 1 mat11 1
= 1 mat11 = 1
1 mat11 = 0 1
mat11 = 0 + 1
= 0 + 4 2
0 + 4 mat12 1
+ 4 mat12 = 1
4 mat12 = 3 1
mat12 = 3 mat13 1
= 3 mat13 = 1
3 mat13 = 2 1
mat13 = 2 + 1
mat20 = 2 mat21 1
= 2 mat21 = 1
2 mat21 = 3 1
mat21 = 3 + 1
= 3 + 4 1
3 + 4 mat22 1
+ 4 mat22 = 1
4 mat22 = 0 1
mat22 = 0 + 1
0 + 4 mat23 1
+ 4 mat23 = 1
mat30 = 3 mat31 1
= 3 mat31 = 1
3 mat31 = 2 1
mat31 = 2 mat32 1
= 2 mat32 = 1
2 mat32 = 1 1
mat32 = 1 + 1
= 1 + 4 1
1 + 4 mat33 1
+ 4 mat33 = 1
4 mat33 = 0 1
mat33 = 0 + 1
i < 8 i 1
j < 8 j 1
if i > 4 2
i > 4 | 1
> 4 | j 1
4 | j > 1
| j > 4 1
matij = mati 4 1
i > 4 j 1
> 4 j > 1
4 j > 4 1
j > 4 matij 1
> 4 matij = 1
int goint st int 1
goint st int goal 1
cur = 0 i 1
= 0 i = 2
for i = st 1
i = st i 1
= st i < 1
st i < n 1
if cur = goal 1
cur = goal return 1
= goal return i 1
goal return i + 1
int calcint l int 1
calcint l int r 1
int t = 1 10
1 t < tst 2
t < tst t 2
< tst t + 2
for len = 12 1
len = 12 len 1
if len 4 = 1
len 4 = cnt 1
4 = cnt 4 1
if cnt < len 1
cnt < len len 1
< len len = 1
1 i < len 1
i < len i 1
< len i + 1
< n j + 1
n j + strj 1
j + strj + 1
+ strj + i 1
strj + i n 1
+ i n = 1
int md1 = go0 1
if md1 = -1 1
md1 = -1 | 1
= -1 | md1 1
-1 | md1 = 1
| md1 = n 1
int md2 = gomd1 1
if md2 = -1 1
md2 = -1 | 1
= -1 | md2 1
-1 | md2 = 1
| md2 = n 1
if calcmd2 n = 1
calcmd2 n = 3 1
if clp < i 1
typedef vectorlong long vll 3
typedef vectorvectorlong long > 3
vectorvectorlong long > vvll 3
define VVT vectorvector T 3
VVT vectorvector T > 3
void initvvvectorvectorT > v 3
initvvvectorvectorT > v int 3
> v int a 3
v int a int 3
a int b const 3
int b const T 3
b const T t 3
const T t = 3
template < F class 3
void convertconst F f 3
convertconst F f T 3
0 j < 4 2
tblij + 4 = 1
+ 4 = tblij 2
4 = tblij + 2
= tblij + 4 2
tbli + 4 = 1
cin > len > 1
> len > x 1
len > x > 1
x - maxx - 1
- maxx - 20 1
maxx - 20 0 1
- 20 0 4 1
0 i < x 2
forLL j = 0 1
0 j < len 1
int mini = 1010101010 1
mini = 1010101010 maxk 1
= 1010101010 maxk = 1
0 i < intvsize 1
forint i = vsize 1
i = vsize i 1
ok = mini + 1
= mini + 1 1
mini + 1 < 1
cout < fixed < 3
cerr < fixed < 3
forint cnum = 1 3
cnum = 1 cnum 3
= 1 cnum < 3
1 cnum < T 3
define repk a b 2
repk a b for 2
a b for int 4
b for int k 4
int k = a 4
k = a k 4
= a k < 2
a k < intb 2
define mir c v 2
mir c v vvir 2
c v vvir vic 2
define rrepk a b 2
rrepk a b for 2
= a k > 2
a k > intb 2
define irepk a for 2
irepk a for auto 2
a for auto k 2
define mdr c v 2
mdr c v vvdr 2
c v vvdr vdc 2
define mbr c v 2
mbr c v vvbr 2
c v vvbr vbc 2
define msr c v 2
msr c v vvsr 2
c v vvsr vsc 2
define mlr c v 2
mlr c v vvlr 2
c v vvlr vlc 2
define mcr c v 2
mcr c v vsr 2
c v vsr stringc 2
define addi j i 2
addi j i + 2
j i + j 2
define muli j i 2
muli j i j 2
else if n < 1
1 = 1 2 1
= 1 2 = 1
1 2 = i 1
2 = i 3 1
= i 3 = 1
i 3 = j 1
3 = j 4 1
= j 4 = 1
int multint x int 1
multint x int y 1
if absx = 1 1
absx = 1 | 1
= 1 | absy 1
1 | absy = 1
if absx = 2 2
absx = 2 absy 2
= 2 absy = 2
if absx = 3 2
absx = 3 absy 2
= 3 absy = 2
if absx = 4 2
absx = 4 absy 2
= 4 absy = 2
n = n 4 1
= n 4 + 1
prod = multprod c 1
= multprod c - 1
if counter = 0 1
counter = 0 prod 1
= 0 prod = 1
0 prod = 2 1
else if counter = 1
if counter = 1 1
counter = 1 prod 1
= 1 prod = 1
1 prod = 3 1
printfCase d sn X 1
d sn X + 1
sn X + 1 1
X + 1 counter 1
+ 1 counter = 1
1 counter = 2 1
counter = 2 prod 1
= 2 prod = 1
2 prod = 4 1
ostream operatorostream os const 2
operatorostream os const vectorX 1
os const vectorX v 1
repititr v cout < 1
v cout < itr 1
cout < itr < 1
repi n cin > 1
repi n maxy = 1
n maxy = maxmaxy 1
repi n sum + 1
0 i < smax 3
i < smax i 2
if cnt < i 1
printfCase d dn testcase 2
read one scalar from 3
one scalar from text 3
scalar from text file 3
void rdT x inFile 3
rdT x inFile > 3
read scalars from text 3
scalars from text file 3
template < T typename 18
void rdT x Ts 3
rdT x Ts xs 3
x Ts xs inFile 3
Ts xs inFile > 3
xs inFile > x 3
void rdhelpstdvector < v 6
rdhelpstdvector < v T 3
< v T elt 3
v T elt inFile 3
T elt inFile > 6
elt inFile > elt 6
rdhelpstdvector < v stdvector 3
< v stdvector < 6
inFile > elt vpushbackelt 3
read vectors from text 3
void rdint const N 3
rdint const N stdvector 3
const N stdvector < 3
N stdvector < v 3
stdvector < v stdvector 3
for int i0 iN 3
int i0 iN i 3
i0 iN i rdhelpv 3
void prhelp stdcout < 3
void prhelpconst T x 3
prhelpconst T x const 3
T x const Ts 6
x const Ts xs 6
const Ts xs stdcout 6
Ts xs stdcout < 6
void pr stdcout < 3
print scalars separated by 3
scalars separated by spaces 3
separated by spaces followed 3
by spaces followed by 3
spaces followed by a 3
void prconst T x 3
prconst T x const 3
xs stdcout < x 3
for int i0 iintvsize 3
int i0 iintvsize i 3
if i0 stdcout < 3
for auto itsbegin itsend 3
auto itsbegin itsend + 3
if itsbegin stdcout < 3
for auto itmbegin itmend 3
auto itmbegin itmend + 3
stdcout < itfirst < 3
Has effect of m 6
effect of m = 6
const T mxeqT m 3
T mxeqT m const 3
mxeqT m const T 3
m const T v 6
const T v m 6
T v m = 6
v m = stdmaxmv 3
m = stdmaxmv return 3
const T mneqT m 3
T mneqT m const 3
mneqT m const T 3
v m = stdminmv 3
m = stdminmv return 3
for int m1 mmm 1
int m1 mmm m 1
int i0 iD + 1
tm + Pim1m - 1
mainint argc char const 6
make sure filename is 3
if argc = 2 3
argc = 2 prExpected 3
= 2 prExpected one 3
2 prExpected one argument 3
open input file and 3
input file and get 3
file and get number 3
and get number of 3
int T inFileopenargv1 rdT 3
for int caseIndex1 caseIndexT 3
int caseIndex1 caseIndexT caseIndex 3
int solve int g 1
FILE reader = fopenAlargein 1
forint i0 iSmax i 2
standing = i + 1
START OF TEMPLATE CODE 3
define FEi x for 3
FEi x for auto 3
x for auto i 3
for auto i = 3
auto i = beginx 3
i = beginx i 3
= beginx i = 3
beginx i = endx 3
templateclass T T gcdT 3
T T gcdT a 3
T gcdT a T 3
gcdT a T b 3
a T b return 3
T b return b 3
b return b gcdb 3
return b gcdb a 3
b gcdb a b 3
gcdb a b a 3
static void redirectint argc 3
void redirectint argc const 3
redirectint argc const char 3
int fd = openargv1 3
if fd = -1 6
fd = -1 perrorargv1 3
= -1 perrorargv1 exit1 3
if 1 = dup2fd 6
1 = dup2fd 0 3
= dup2fd 0 perrorargv1 3
dup2fd 0 perrorargv1 exit1 3
if 1 = closefd 6
1 = closefd perrorargv1 3
= closefd perrorargv1 exit1 3
int fd = openargv2 3
fd = openargv2 OWRONLY 3
= openargv2 OWRONLY | 3
openargv2 OWRONLY | OCREAT 3
fd = -1 perrorargv2 3
= -1 perrorargv2 exit1 3
1 = dup2fd 1 3
= dup2fd 1 perrorargv2 3
dup2fd 1 perrorargv2 exit1 3
1 = closefd perrorargv2 3
= closefd perrorargv2 exit1 3
END OF TEMPLATE CODE 3
int mainint argc const 3
mainint argc const char 3
for int cas = 3
int cas = 0 3
cas = 0 cas 3
= 0 cas < 3
0 cas < cases 3
1 t < pback 1
cost + pi - 1
inline int multiplyint a 1
inline int powquatint a 1
int powquatint a long 1
powquatint a long long 1
inline int getinvint y 1
int getinvint y int 1
inline int getint l 1
int getint l int 1
powX a get0 l 1
a get0 l = 1
getl1 N1 powX b 1
N1 powX b get0 1
powX b get0 r1 1
b get0 r1 = 1
getr N1 powX c 1
N1 powX c = 1
forint X4 X4 X 1
forint i4 i4 i 1
forint j4 j4 j 1
forint k4 k4 k 1
forint l4 l4 l 1
forint a0 a4 a 1
a0 a4 a ifmultiplypowquatX 1
a4 a ifmultiplypowquatX a 1
forint b0 b4 b 1
b0 b4 b ifmultiplyj 1
b4 b ifmultiplyj multiplypowquatX 1
b ifmultiplyj multiplypowquatX b 1
forint c0 c4 c 1
c0 c4 c ifmultiplyl 1
c4 c ifmultiplyl powquatX 1
int n scanfds n 1
n scanfds n a 1
scanfds n a + 1
s = 0 ans 1
s + ai - 1
+ i - s 1
i - s s 1
- s s = 1
char multiplychar a char 1
void solvecaseifstream fin ofstream 3
solvecaseifstream fin ofstream fout 3
fin ofstream fout int 3
fin > l > 2
> l > x 1
l > x > 1
int n = 0 1
n = 0 i 1
0 i = 0 1
i = 0 nothing 1
= 0 nothing = 1
while x n < 1
x n < 3 1
while i < ssize 1
i < ssize c 1
< ssize c = 1
if i = ssize 1
if n = 3 1
cout < x < 1
fout < n = 1
< n = 3 1
n = 3 c 1
= 3 c = 1
3 c = 1 1
int t t1 = 3
while t1 < t 3
define fordabc for int 1
a < 0 res 1
< 0 res = 2
0 res = -1 2
res = -1 a 1
= -1 a = 1
b < 0 res 1
res = -1 b 1
= -1 b = 1
int pangkatint xlong long 1
if y = 1 1
y = 1 return 1
if y 2 = 1
y 2 = 0 1
2 = 0 return 1
kecil = besar = 1
kecil = i n 1
= i n + 1
if kecil = -1 1
besar = x n 1
= x n - 1
x n - i 1
n - i n 1
- i n + 1
n + j - 1
if besar = -1 1
for int i0 in 1
for int i1 in 1
int i1 in + 1
if cek < i 1
cek + si - 1
int multiplyint p int 2
FILE reader = fopenClargein 1
forint i0 iL i 1
for int x0 xX 1
for findi0 finditotallength findi 1
for findjfindi1 findjtotallength findj 1
for findkfindj1 findktotallength findk 1
int dpint a int 1
repi D cin > 1
forint m1 m1000 m 1
repi D sp + 1
D sp + Pi 1
sp + Pi - 1
+ Pi - 1 1
ans = minans sp 1
= minans sp + 1
forLL x = 1 1
x = 1 x 1
= 1 x < 1
1 x < 1010 1
s + pi - 1
1 t < tt 3
int d res = 1
0 i < d 5
1 i < res 1
0 j < d 2
cur + pj - 1
+ pj - 1 1
void validateT parameter T 3
validateT parameter T min 3
parameter T min T 3
T min T max 3
ifparameter < min parameter 3
< min parameter > 3
static Qmin multbuff83need to 1
Qmin multbuff83need to multiply 1
multbuff83need to multiply by 1
to multiply by ij 1
multiply by ij or 1
by ij or k 1
inline static int QindexQmin 1
static int QindexQmin f 1
int QindexQmin f Qmin 1
QindexQmin f Qmin s 1
f Qmin s return 1
Qmin s return intf 1
s return intf + 1
return intf + 8 1
intf + 8 ints 1
+ 8 ints - 1
8 ints - 1 1
static inline Qmin multQmin 1
inline Qmin multQmin f 1
Qmin multQmin f Qmin 1
multQmin f Qmin s 1
static inline Qmin powerQmin 1
inline Qmin powerQmin f 1
Qmin powerQmin f int 1
powerQmin f int x 1
return Qmin intf + 1
Qmin intf + 48 1
throw new stdexceptionshould be 1
new stdexceptionshould be impossible 1
stdexceptionshould be impossible to 1
be impossible to have 1
impossible to have another 1
in > L > 1
stupid way to read 1
way to read a 1
to read a given 1
read a given length 1
a given length string 1
given length string but 1
length string but should 1
i < L + 1
int checktotalmax = L 1
checktotalmax = L 4 1
= L 4 anything 1
L 4 anything power 1
4 anything power to 1
anything power to 4 1
power to 4 is 1
to 4 is equal 1
4 is equal to 1
is equal to one 1
equal to one so 1
to one so if 1
one so if not 1
so if not found 1
if not found in 1
not found in 4 1
found in 4 cyckes 1
in 4 cyckes = 1
4 cyckes = not 1
cyckes = not found 1
= not found at 1
for checktotalmax > 0 1
checktotalmax > 0 - 1
iL = iX = 1
total result should be 1
if powersumStr X4 = 1
powersumStr X4 = minusone 1
rest should be one 1
should be one and 1
be one and added 1
one and added to 1
and added to last 1
added to last j 1
to last j because 1
last j because already 1
j because already checked 1
because already checked that 1
already checked that total 1
checked that total is 1
that total is minus 1
forint iT = 1 3
iT = 1 iT 3
= 1 iT < 3
1 iT < T 3
iT < T + 3
define repian for int 3
define perian for int 3
ll powmodll all b 3
powmodll all b ll 3
all b ll res1amodforbb1ifb1resresamodaaamodreturn 3
int S csum = 1
S csum = 0 1
csum = 0 ans 1
0 i < S 1
i < S + 1
int num = shyi 1
num = shyi - 1
if num ans = 1
num ans = maxans 1
ans = maxans i 2
= maxans i - 2
REPi D scanfd P 1
D scanfd P + 1
now + Pj - 1
+ Pj - 1 2
define gx y z 1
gx y z forint 1
define hx y z 1
hx y z forint 1
= y x > 1
y x > z 1
num mul256256 ONE I 1
mul256256 ONE I J 1
ONE I J K 1
inline num operator num 1
num operator num x 1
operator num x num 1
ifxneg = yneg tmpneg 1
= yneg tmpneg = 1
inline bool operator = 2
bool operator = x 2
operator = x num 2
return xch = ych 2
xch = ych xneg 1
= ych xneg = 1
xch = ych | 1
= ych | xneg 1
ych | xneg = 1
IJK = I J 1
x = num c 1
inline num pownum x 1
num pownum x LL 1
ify 1 < i 1
1 < i ans 1
< i ans = 1
i ans = ans 1
readai prodi = prodi 1
prodi = prodi - 1
= prodi - 1 1
num tmp = powprodn 1
printftmp c dn tmpch 1
printfIJK c dn IJKch 1
ifup > 4 up 2
> 4 up = 2
num c = powprodn 1
c = powprodn j 1
LL ca = i 1
ca = i + 1
= i + j 1
ifca < ans ans 1
succn + 1 = 1
hi n 1 succi 1
n 1 succi = 1
1 succi = ai 1
succi = ai succi 1
= ai succi + 1
num c = succi 1
c = succi powsucc1 1
LL ca = n 1
ca = n + 1
= n + 1 1
n + 1 - 1
+ 1 - i 1
1 - i + 1
- i + j 1
ifca < a2 a2 1
< a2 a2 = 1
printfans I64d I64dn ans 1
LL tl = LL 1
tl = LL n 1
ifans + a2 < 1
+ a2 < tl 1
a2 < tl printfCase 1
< tl printfCase d 1
tl printfCase d YESn 1
else printfCase d NOn 1
int funcint a int 1
int neg = a 1
neg = a b 1
else if b = 1
else if a = 1
else if b - 1
if b - 2 1
b - 2 = 1
- 2 = a 1
2 = a - 1
= a - 1 1
res = 9 - 1
= 9 - a 1
9 - a - 1
res = a + 1
= a + b 1
a + b - 1
0 i < slength 1
cur = funccur si 1
= funccur si - 1
if cur = -1 2
cur = -1 x 1
= -1 x 2 1
-1 x 2 = 1
x 2 = 1 2
2 = 1 | 1
= 1 | abscur 1
1 | abscur = 1
| abscur = 1 1
abscur = 1 x 1
= 1 x 4 1
1 x 4 = 1
int ind = 0 1
ind = 0 num 1
= 0 num = 1
cur = funccur sind 1
= funccur sind - 1
if cur = 2 2
cur = 2 stage 1
= 2 stage = 1
else if cur = 2
if cur = 3 1
cur = 3 stage 1
= 3 stage = 1
if cur = 4 2
cur = 4 stage 1
= 4 stage = 1
if num > 12 1
num > 12 | 1
> 12 | num 1
12 | num > 1
turns + vi + 1
+ vi + eat 1
vi + eat - 1
+ eat - 1 1
eat - 1 eat 1
- 1 eat - 1
forint x = 1005 1
x = 1005 x 1
= 1005 x > 1
1005 x > 1 1
We try to only 1
try to only have 1
to only have pots 1
only have pots with 1
have pots with maximum 1
ifPi x = 0 1
x = 0 moves 1
= 0 moves + 1
0 moves + Pix 1
moves + Pix - 1
possible = moves + 1
FILE fin = freopenAlargein 1
FILE fout = freopenAlargeout 1
ifadd + sum < 1
+ sum < i 1
sum < i k 1
< i k > 1
cout < add < 1
ifnullptr = s delete 1
i < smax + 1
int deltaextra = total 1
deltaextra = total < 1
= total < i 1
total < i itotal 1
out < extra < 1
stdcout < stdsetprecision7 < 1
coutsetf stdiosfixed std iosfloatfield 2
stdiosfixed std iosfloatfield floatfield 2
std iosfloatfield floatfield set 2
iosfloatfield floatfield set to 2
const long long MOD 2
long long MOD = 2
define REPiN for int 2
REPiN for int i 2
templateclass T void printImplconst 2
T void printImplconst vectorT 2
void printImplconst vectorT coll 2
printImplconst vectorT coll copycollbegin 2
vectorT coll copycollbegin collend 2
coll copycollbegin collend ostreamiteratorTcout 2
templateclass T int N 2
T int N void 2
int N void printImplT 2
N void printImplT collN 2
void printImplT collN copycoll 2
printImplT collN copycoll coll 2
collN copycoll coll + 2
copycoll coll + N 2
coll + N ostreamiteratorTcout 2
templateclass Key class Value 2
Key class Value void 2
class Value void printImplconst 2
Value void printImplconst mapKey 2
void printImplconst mapKey Value 2
printImplconst mapKey Value data 2
mapKey Value data typename 2
Value data typename mapKey 2
data typename mapKey Valueconstiterator 2
typename mapKey Valueconstiterator it 2
mapKey Valueconstiterator it for 2
Valueconstiterator it for it 2
it for it = 2
for it = databegin 2
it = databegin it 2
= databegin it = 2
databegin it = dataend 2
it = dataend + 2
= dataend + cout 2
dataend + cout < 2
+ cout < itfirst 2
cout < itfirst < 2
template < T void 2
< T void printImplconst 2
T void printImplconst T 2
void printImplconst T data 2
printImplconst T data cout 2
T data cout < 2
data cout < data 2
cout < data < 2
< data < endl 2
define printx cout < 2
printx cout < x 2
cout < x = 2
int multijkint a int 1
const static int m88 2
assert0 < a a 2
< a a < 2
assert0 < b b 2
< b b < 2
int divijkint a int 1
int powijkint a ll 1
if p 4 = 4
p 4 = 0 1
4 = 0 return 1
p 4 = 1 1
4 = 1 return 1
p 4 = 2 1
4 = 2 return 1
= 2 return multijka 1
p 4 = 3 1
4 = 3 return 1
= 3 return multijkmultijka 1
3 return multijkmultijka a 1
bool possibleconst string ss 1
possibleconst string ss ll 1
string ss4 = ss 1
ss4 = ss + 1
= ss + ss 1
ss + ss + 2
+ ss + ss 1
i < 4 N 1
int firstIpos = -1 1
firstIpos = -1 lastKpos 1
= -1 lastKpos = 1
if firstIpos = -1 2
firstIpos = -1 resi 1
= -1 resi = 1
if divijkresi res4N1 = 1
firstIpos = -1 | 1
= -1 | lastKpos 1
-1 | lastKpos = 1
ll totalLength = firstIpos 1
totalLength = firstIpos + 1
= firstIpos + 1 1
firstIpos + 1 + 1
+ 1 + 4 1
1 + 4 N 1
+ 4 N - 1
if totalLength > N 1
for int csIx = 3
int csIx = 1 3
csIx = 1 csIx 3
= 1 csIx < 3
1 csIx < caseCount 3
bool res = possibless 1
0 i < sizes 8
if i 16 = 1
i 16 = 0 1
16 = 0 cout 1
= 0 cout < 1
cout < charatual < 1
else if atual = 1
else if X = 4
if X = 1 1
if X = 2 1
if X = 6 1
char prodchar q1 int 1
prodchar q1 int qs 1
q1 int qs char 1
for int i1 iX 1
int i1 iX + 1
for int64t i0 iint64tcsize 1
int64t i0 iint64tcsize + 1
p = p + 1
1 t < tests 3
t < tests + 3
i < d + 1
cout < ai < 1
ans = ad - 1
1 i < ad 1
i < ad - 1
< ad - 1 1
ad - 1 + 1
j < d + 1
int x = aj 1
if x i < 1
x i < aj 1
count + x - 1
if count + i 1
count + i < 1
+ i < ans 1
i < ans ans 1
ans ans = count 1
ans = count + 1
inline ee mulee achar 1
ee mulee achar ch 1
else if ansp1 ansck 1
if i j ansp1 1
int res = 0 2
res = 0 su 1
= 0 su = 1
int smax r = 1
smax r = 0 1
r = 0 sum 1
fin > smax > 1
sum = s0 - 1
1 i < smax 1
r + i - 1
sum + si - 3
fout < r < 2
tablei + 4 = 1
+ 4 = ptableij 2
tableij + 4 = 1
tablei + 4 + 1
+ 4 + 4 1
4 + 4 = 1
int idx = c 1
idx = c - 1
bool ans = need 1
ans = need > 1
= need > 3 1
need > 3 tcur 1
> 3 tcur = 1
cuts + p - 1
+ p - 1 1
best = minbest cuts 1
= minbest cuts + 1
printfCase d dn X 2
d dn X + 2
dn X + 1 2
nSpec + Ppi + 1
ans = min ans 1
res = 0 cur 1
0 i < s 2
res + i - 1
cur + c - 1
int d r = 1
0 j < pd1 1
j < pd1 j 1
dp0j = p0 + 1
= p0 + j 1
p0 + j j 1
+ j j + 1
1 i < d 1
i < d i 3
m = minm maxdpi1jk 1
= minm maxdpi1jk pi 1
minm maxdpi1jk pi + 1
maxdpi1jk pi + k 1
pi + k k 1
+ k k + 1
r = minr j 1
= minr j + 1
int a442 = 0 1
a442 = 0 0 1
= 0 0 1 1
0 0 1 0 1
0 1 0 2 1
1 0 2 0 1
0 2 0 3 1
1 0 0 1 1
0 0 1 3 1
0 1 3 0 1
1 3 0 2 1
2 0 3 1 1
0 3 1 0 1
3 1 0 1 1
1 0 1 1 1
3 0 2 0 1
0 2 0 1 1
2 0 1 1 1
0 1 1 0 1
Foo multint x1 int 1
multint x1 int x2 1
x1 int x2 long 1
int x2 long long 1
x2 long long x 1
if x = 1 1
if x 2 = 1
long long w = 1
long w = x 1
Foo sub = multx1 1
sub = multx1 x2 1
ansq2 = asubq1ansq11 + 2
= asubq1ansq11 + subq2 2
asubq1ansq11 + subq2 + 2
+ subq2 + ansq2 2
if strlength = 1 1
if x < 8 1
i < x - 1
< x - 1 1
int count = strlength 1
count = strlength + 1
int x2 = 0 1
0 i < strlength 1
i < strlength + 3
x2 = ax1stri - 3
x1 = ax1stri - 3
if x1 = 1 1
x1 = 1 x2 1
= 1 x2 = 1
1 x2 = 0 1
count = i + 1
int y2 = 0 1
int i = strlength 1
i = strlength i 1
= strlength i > 1
strlength i > 1 1
y2 = astri - 1
= astri - 1 2
astri - 1 - 2
y1 = astri - 1
if y1 = 3 1
y1 = 3 y2 1
= 3 y2 = 1
3 y2 = 0 1
count + strlength - 1
+ strlength - i 1
strlength - i + 1
x1 = astr0 - 2
x2 = astr0 - 2
int i = 2 2
i = 2 i 2
= 2 i < 2
2 i < strlength 2
if count < strlength 1
count < strlength x1 1
< strlength x1 = 1
strlength x1 = 0 1
x1 = 0 x2 1
= 0 x2 = 1
0 x2 = 1 1
int x1 = astr0 1
int x2 = astr0 1
0 j < strlength 1
j < strlength + 1
if j1 = 1 1
j1 = 1 j2 1
= 1 j2 = 1
1 j2 = 0 1
j2 = aj1strj - 1
j1 = aj1strj - 1
i2 = ai1x11 + 1
= ai1x11 + x2 1
ai1x11 + x2 + 1
+ x2 + i2 1
int j = strlength 1
j = strlength j 1
= strlength j > 1
strlength j > 1 1
j > 1 - 1
if j1 = 3 1
j1 = 3 j2 1
= 3 j2 = 1
3 j2 = 0 1
j2 = astrj - 1
= astrj - 1 2
astrj - 1 - 2
j1 = astrj - 1
k2 = ax1k11 + 1
= ax1k11 + x2 1
ax1k11 + x2 + 1
+ x2 + k2 1
Foo q = multx1 1
q = multx1 x2 1
if flagi flagk qq1 1
flagi flagk qq1 = 1
flagk qq1 = 0 1
qq1 = 0 qq2 1
= 0 qq2 = 1
0 qq2 = 1 1
cin > Sm > 1
0 i < Sm 1
stand + freqi - 1
assertD > 1 D 1
> 1 D < 1
i < D i 1
assertPi > 1 Pi 1
> 1 Pi < 1
first do all the 1
then let them eat 1
let them eat for 1
them eat for no 1
eat for no more 1
for no more than 1
no more than i 1
0 j < D 1
j < D j 1
cur + Pj - 1
assertT > 1 T 3
> 1 T < 3
0 i < T 3
i < T i 1
n i + scanfd 1
i + scanfd pi 1
+ scanfd pi nonemp 1
scanfd pi nonemp | 1
pi nonemp | pi 1
nonemp | pi = 1
if nonemp ans = 1
for int left = 1
int left = 1 1
left = 1 left 1
= 1 left < 1
1 left < 1000 1
left < 1000 left 1
< 1000 left + 1
if pi left = 1
pi left = 0 1
left = 0 sum 1
bool solveint st int 1
need + ai + 1
+ ai + x 1
ai + x - 1
+ x - 1 1
x - 1 x 1
- 1 x - 1
int l = 0 1
while r - l 2
r - l > 2
int m = l 2
m = l + 2
for int st = 1
int st = 0 1
st = 0 st 1
= 0 st < 1
0 st < maxn 1
ans = minans solvest 1
eprintfCase d of d 1
d of d i 1
const int maxd = 1
int h = pans0 1
h = pans0 h 1
= pans0 h - 1
if pansi -1 < 1
cnt + pansi -1 1
result = minresult cnt 1
= minresult cnt + 1
A + it k 1
+ it k - 1
it k - it 1
ifA + k < 1
out = A + 1
long long minint xlong 1
long minint xlong long 1
0 i < sizevet 1
v + veti - 1
if v + d 1
v + d < 1
+ d < min 1
d < min min 1
min min = v 1
min = v + 1
0 i < n1 1
i < n1 i 1
int maxp = maxelementdat 1
for int maxv = 1
int maxv = 1 1
maxv = 1 maxv 1
= 1 maxv < 1
1 maxv < maxp 1
maxv < maxp maxv 1
< n i stage1 1
n i stage1 + 1
i stage1 + dati 1
stage1 + dati - 1
+ dati - 1 1
ans = minans stage1 1
= minans stage1 + 1
int sum = 0 1
sum = 0 ans 1
sum < i ans 1
+ i - sum 1
i - sum sum 1
- sum sum = 1
sum + stri - 1
printfCase d dn tst 1
assertint ssize = l 1
ssize = l + 1
i < l i 2
int delta = maxi 1
delta = maxi + 1
= maxi + 1 1
maxi + 1 - 1
+ 1 - sum 1
int reqResultM = MM123 1
int reqResultS = SS123 1
cout < reqResultM < 1
cout < m < 1
ifcnt = 0 cnt 1
= 0 cnt = 1
ifrm = reqResultM | 1
= reqResultM | rs 1
reqResultM | rs = 1
| rs = reqResultS 1
cout < st < 1
int b = -1 1
b = -1 e 1
= -1 e = 1
ifm = 1 s 1
= 1 s = 1
1 s = 1 1
ifm = 3 s 1
= 3 s = 1
3 s = 1 1
cout < b < 1
ifb = -1 | 1
= -1 | e 1
-1 | e = 1
| e = -1 1
e = -1 | 1
= -1 | LX 1
-1 | LX < 1
| LX < llblle 1
LX < llblle printfCase 1
< llblle printfCase d 1
llblle printfCase d NOn 1
else printfCase d YESn 1
char c cin > 1
c cin > c 1
cin > c c 1
> c c - 1
ans + j - 2
const int maxs = 1
i < s i 1
int cur = leveli 1
app + max0 i 1
+ max0 i - 1
max0 i - cnt 1
i - cnt + 1
0 s < S 1
int needToAdd = maxs 1
needToAdd = maxs - 1
= maxs - currStanding 1
currStanding + sss - 1
cin > sMax > 1
0 j < sMax 1
j < sMax + 1
aj = strj - 1
if s < j 1
Problem P = nullptr 1
Problem ifP delete P 1
forint eat = 1 1
eat = 1 eat 1
= 1 eat < 1
1 eat < minminutes 1
eat < minminutes + 1
special + Pi1 eat 1
+ Pi1 eat number 1
Pi1 eat number of 1
eat number of groups 1
number of groups to 1
of groups to devide 1
groups to devide to 1
to devide to is 1
devide to is one 1
ifspecial + eat < 1
+ eat < minminutes 1
minminutes = special + 2
forint special = 1 1
special = 1 special 1
= 1 special < 1
1 special < minminutes 1
special < minminutes + 1
int newP2 = maxP 1
newP2 = maxP - 1
ifspecial + maxP < 1
+ maxP < minminutes 1
stdcerr < special < 1
forint i = maxP 1
i = maxP i0 1
0 j < Pi 1
stdcerr < i < 1
out < minminutes < 1
repi08 repj08 if i4j4 1
repi0n if sii ti1 1
if sii ti1 else 1
sii ti1 else if 1
ti1 else if sij 1
else if sij ti2 1
if sij ti2 else 1
FILE fin = freopenBlargein 1
FILE fout = freopenBlargeout 1
< n i cin 1
n i cin > 1
cout < answer < 1
int total = 0 1
total = 0 add 1
= 0 add = 1
0 i < Ssize 1
0 i < SMax 2
encours = i + 1
const long long MAXLEN 1
long long MAXLEN = 1
const long long MAXX 1
long long MAXX = 1
const long long MAXLX 1
long long MAXLX = 1
const long long NOTFOUND 1
long long NOTFOUND = 1
long NOTFOUND = numericlimitslong 1
const long long SOMEGENEROUSUPPERBOUND 1
long long SOMEGENEROUSUPPERBOUND = 1
int table4 = pos1 1
table4 = pos1 posI 1
= pos1 posI posJ 1
int val quaternions in 1
val quaternions in order 1
quaternions in order 1 1
in order 1 i 1
order 1 i j 1
1 i j k 1
i j k -1 1
j k -1 - 1
k -1 - - 1
bool operatorconst quaternion other 2
operatorconst quaternion other const 3
quaternion operatorconst quaternion other 2
int sgn = 4 1
sgn = 4 val 1
= 4 val 4 1
4 val 4 + 1
val 4 + 4 1
4 + 4 otherval 1
val = tableval 4. 1
= tableval 4. 4 1
tableval 4. 4 + 1
4. 4 + sgn 1
friend ostream operatorostream os 1
operatorostream os const quaternion 1
os const quaternion q 1
os < qval > 1
< qval > 4 1
quaternion powquaternion q long 1
powquaternion q long long 1
q long long exponent 1
1 i < exponent 1
i < exponent i 1
< exponent i < 1
exponent i < 1 1
if exponent i ans 1
exponent i ans = 1
long long findPartialquaternion q 1
long findPartialquaternion q long 1
findPartialquaternion q long long 1
q long long start 1
int practicalX = minSOMEGENEROUSUPPERBOUND 1
long long found = 1
0 j < practicalX 1
j < practicalX j 1
long long curPos = 1
long curPos = L 1
curPos = L j 1
= L j + 1
if curPos > start 1
curPos > start powersj 1
> start powersj partiali 1
start powersj partiali = 1
assertL > 1 L 1
> 1 L < 1
assertX > 1 X 1
> 1 X < 1
partiali + 1 = 1
+ 1 = partiali 1
1 = partiali quaternion 1
= partiali quaternion si 1
partiali quaternion si - 1
assertpowpartialL X = powpartialL 1
X = powpartialL X 1
= powpartialL X 4 1
powpartialL X 4 just 1
X 4 just checking 1
if powpartialL X = 1
1 i < SOMEGENEROUSUPPERBOUND 1
i < SOMEGENEROUSUPPERBOUND i 1
powersi = powersi - 1
= powersi - 1 1
assertpowersi = powpartialL i 1
= powpartialL i again 1
powpartialL i again just 1
long long firstI = 1
long firstI = findPartialposI 1
if firstI = NOTFOUND 1
firstI = NOTFOUND return 1
long long firstK = 1
long firstK = findPartialposK 1
quartchar type int sign 1
type int sign typetype 1
int sign typetype signsign 1
repi minx 6 s 1
minx 6 s + 1
ifipos = -1 ans 1
= -1 ans = 2
ifkpos = -1 ans 1
ll rkpos = llssize 1
rkpos = llssize - 1
= llssize - kpos 1
llssize - kpos - 1
ifipos > xl - 1
> xl - rkpos 1
xl - rkpos - 1
maxdiff = maxmaxdiff i 1
= maxmaxdiff i - 1
num + stri - 1
1 1 i j 1
i i 1 k 1
j j k 1 1
k k j i 1
return Mabsa1absb1 ab > 1
Mabsa1absb1 ab > 0 1
ab > 0 1 1
ll ipos = -1 1
ipos = -1 kpos 2
= -1 kpos = 3
repi 4 t + 1
repi L cur = 1
L cur = multcur 1
if abscur = 1 1
cur = -1 X 1
= -1 X 2 1
-1 X 2 = 1
X 2 = 1 1
if X 4 = 1
X 4 = 2 1
cur = 2 ipos 1
= 2 ipos = 1
2 ipos = -1 1
ipos = -1 ipos 1
= -1 ipos = 1
cur = 4 kpos 1
= 4 kpos = 1
4 kpos = -1 1
kpos = -1 kpos 1
if ipos = -1 1
-1 kpos = -1 1
kpos = -1 ipos 1
= -1 ipos < 1
-1 ipos < LX1kpos 1
int v 0123 for 1
int q = multv 1
q = multv 3. 1
const quad target = 1
int TC cin > 1
forint tc = 1 1
tc = 1 tc 1
= 1 tc < 1
1 tc < TC 1
X = X12 + 1
first read the string 1
read the string of 1
quad curtarget1 first try 1
curtarget1 first try to 1
first try to make 1
ifcurv = curtargetv curtargetv 1
= curtargetv curtargetv = 1
bool anscurtargetv = 3 1
1 4 3 6 1
2 7 4 1 1
3 2 5 4 1
int prod int a 1
prod int a int 1
int m = multa 1
m = multa 4 1
if a > 3 1
a > 3 b 1
> 3 b > 1
3 b > 3 1
b > 3 m 1
> 3 m = 1
3 m = m 1
m = m + 1
= m + 4 1
abb = x < 1
= x < x 1
x < x 4 1
< x 4 + 1
x 4 + 12 2
4 + 12 x 1
+ 12 x x 1
12 x x 4 1
x x 4 + 1
while pos < abb 3
pos < abb l 3
< abb l p 2
abb l p = 2
l p = 1 1
p = prod p 3
= prod p spos 3
prod p spos l 3
if p = 1 1
l p = 2 1
if p = 2 1
if p = 3 1
Qint v = 1 1
v = 1 vv 1
if chk v < 1
chk v < 0 1
v < 0 goodv 1
< 0 goodv goodv 1
0 goodv goodv pfBADn 1
if v1 < 0 1
v1 < 0 v1 1
< 0 v1 = 1
0 v1 = -1 1
v1 = -1 sgn 1
= -1 sgn = 1
if v2 < 0 1
v2 < 0 v2 1
< 0 v2 = 1
0 v2 = -2 1
v2 = -2 sgn 1
= -2 sgn = 1
int sqs8 = 1 1
sqs8 = 1 I 1
= 1 I J 1
1 I J K 1
I J K -1 1
J K -1 - 1
K -1 - - 1
good1 = goodI = 1
= goodI = goodJ 1
goodI = goodJ = 1
= goodJ = goodK 1
goodJ = goodK = 1
mul11 = 1 mul1I 1
= 1 mul1I = 1
1 mul1I = I 1
mul1I = I mul1J 1
= I mul1J = 1
I mul1J = J 1
mul1J = J mul1K 1
= J mul1K = 1
mulI1 = I mulII 1
= I mulII 1 1
I mulII 1 mulIJ 1
mulII 1 mulIJ = 1
1 mulIJ = K 1
mulIJ = K mulIK 1
mulJ1 = J mulJI 1
= J mulJI = 1
J mulJI = mulJJ 1
mulJI = mulJJ 1 1
= mulJJ 1 mulJK 1
mulJJ 1 mulJK = 1
mulK1 = K mulKI 1
= K mulKI = 1
K mulKI = J 1
mulKI = J mulKJ 1
= J mulKJ = 1
J mulKJ = mulKK 1
if x > 32 1
x > 32 x 1
> 32 x - 1
32 x - x 1
x - x - 1
- x - 32 1
x - 32 > 1
- 32 > 2 1
32 > 2 < 1
define flui seqiv = 1
flui seqiv = 1 1
frt4 frv8 ccantv = 1
pfnow at d cn 1
at d cn i 1
frt4 frv8 pcantv = 1
pfstate d dn t 1
if t v ccant1t 1
pftrying ovd d dn 1
ovd d dn ov 1
d dn ov sqsov 1
dn ov sqsov seqiv 1
if sqsov seqiv = 1
sqsov seqiv = sqsvv 1
if ccantv pfcan d 1
ccantv pfcan d dn 1
pfcan d dn t 1
pfCase d sn cas 1
d sn cas ccan30 1
iftmp1 flag1 f2 iarrsize1 1
int stepsToAchieve const vi 1
stepsToAchieve const vi a 1
const vi a int 2
vi a int minMax 1
res + ai - 1
int getMinMaxAfterSmall const vi 1
getMinMaxAfterSmall const vi a 1
vi a int steps 1
for int res = 1
int res = 1 1
res = 1 res 1
= 1 res < 1
1 res < 1000 1
if stepsToAchievea res < 1
int getMinMaxAfter int steps 1
getMinMaxAfter int steps const 1
int steps const vi 1
steps const vi sta 1
int l = 1 1
l = 1 r 1
= 1 r = 1
1 t < 1000 1
0 t < 1000 1
int willNeedSteps = getMinMaxAftert 1
res = minres t 1
= minres t + 1
a int b 08 1
void seint i int 1
seint i int w 1
i int w int 1
int w int l 1
FO i0N1 sCouni = 1
if soFar < i 1
int c = 0 1
c = 0 res 1
= 0 res = 1
res + d c 1
+ d c + 1
int lim = 0 1
lim = 0 ans 1
if ai > lim 1
ai > lim lim 1
> lim lim = 1
1 i < lim 1
j < n + 1
n + if aj 1
+ if aj > 1
if aj > i 1
aj > i now 1
> i now + 1
i now + aj 1
now + aj - 1
+ aj - 1 1
if now < ans 1
now < ans ans 1
ans = 0 total 1
= 0 total = 1
repi 0 n + 1
0 n + 1 1
total + c - 1
ans = maxi - 1
= maxi - total 1
maxi - total + 1
- total + 1 1
int N cin > 1
for int k0 kN 1
int k0 kN k 1
ans = 0 standing 1
= 0 standing = 1
0 standing = s0 1
standing = s0 - 1
if standing < i 1
standing + si - 1
